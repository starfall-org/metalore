enum ChatRole {
  user,
  model,
  system,
  tool,
  developer,
} // developer is replacement for system role in OpenAI's official API

class ChatMessage {
  /// auto-generated unique ID
  final String id;

  /// Role of the message
  final ChatRole role;

  /// Text content of the message
  final String content;

  /// Timestamp of the message
  final DateTime timestamp;

  /// Paths (or URIs) attached by the user
  final List<String> attachments;

  /// Optional hidden reasoning content for assistant (collapsed dropdown in UI)
  final String? reasoningContent;

  /// Media generated by AI (images/videos/audios URIs) rendered in assistant block
  final List<String> aiMedia;

  ChatMessage({
    required this.id,
    required this.role,
    this.content = '',
    DateTime? timestamp,
    this.attachments = const [],
    this.reasoningContent,
    this.aiMedia = const [],
  }) : timestamp = timestamp ?? DateTime.now();

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'role': role.name,
      'content': content,
      'timestamp': timestamp.toIso8601String(),
      'attachments': attachments,
      'reasoningContent': reasoningContent,
      'aiMedia': aiMedia,
    };
  }

  factory ChatMessage.fromJson(Map<String, dynamic> json) {
    return ChatMessage(
      id: json['id'] as String,
      role: ChatRole.values.firstWhere((e) => e.name == json['role']),
      content: (json['content'] ?? '') as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
      attachments:
          (json['attachments'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          const [],
      reasoningContent: json['reasoningContent'] as String?,
      aiMedia:
          (json['aiMedia'] as List<dynamic>?)
              ?.map((e) => e.toString())
              .toList() ??
          const [],
    );
  }
}
